\chapter{Testing}

The unit testing method is used to ensure the robustness of our program, especially during implementation of scanner of parser. The JUnit 4 framework provides excellent support for this method. Following the principle of unit testing, each small unit in our program is tested separately. For example, the scanning of each token type was tested separately using parameterized tests. Both positive and negative test cases, derived from the language specification, were used in this process. 

Because of the continuous nature of our project, the program is also tested incrementally, e.g. after each module is completed it is tested against all test cases that had been created even for previous modules. This approach ensures that any valid input could be run on all modules, while invalid input would fail at some point.

A JUnit test suite is also created so that after each addition/modification all modules could be tested again conveniently to prevent bugs being introduced to the program.

We've also created test case based on the example code Joos 1W language specification~\cite{joos1w}. These tests ensure that the program satisfies the requirements for the language.

In the testing part of assignment 1, we mainly used JUnit testing framework to test different components. \\
For testing scanner, we made a set of test cases for each token type, and then made them as the parameters of parameterized tests. So the input are the different valid and invalid lexemes and expected output is the name of corresponding token type, or exception for invalid cases. Parameterized tests run the test over and over again using different values, such that we can make sure the scanner could recognize all valid tokens, and throw errors for some illegal cases, for example, the first character of an identifier is a number.\\
For testing parser and weeder, we referred the specification of Joos1W language, made some small testcases according to the different features of the language. In that way, we can make sure that the parser can perform correct rejecting and accepting action. Then in order to check whether the parser and weeder could handle more complicated cases, we made some big test cases, combined different kinds of situation.\\
The last stage of testing is run the compiler on marmoset test cases. For those test cases, we also used parameterized testing strategy, so the input are all marmoset test cases for a1, and if the input is accepted by compiler, 0 will be returned, otherwise, compiler returns 42. In this step, the compiler could pass all test cases in marmoset, which means scanner, parser, and weeder are well functional.  


