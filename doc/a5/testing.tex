\chapter{Testing}
\label{testing}
Instead of checking whether the syntactic and semantical problems in object program can be spotted by compiler, the testing for code generation is making sure that the generated machine code is the exact translation from Java source code to x86 assembly. This motivated us to make test cases as small as possible, such that we can test every statement, expression object oriented feature separately. For example, \textit{if} statement was tested in the first place. We made the if condition explicit true or false, put a return statement with constant integer in if body, and checked whether the return value from \textit{test} method is correct.

In machine code level, we need to manipulate memory directly, so even a tiny misconduct may cause the memory corruption. Thus we tried making the test cases as many as possible, such that different scenarios can be tested, like the different combination of expressions and statements, and the robustness of the compiler can be verified.     

Once a feature of Java is implemented in x86 assembly, we will rerun all the previous test cases to ensure that no new bugs are introduced to the program, and the machine code can run appropriately as we expected. 

JUnit 4 provided concise and accurate testing approach to us in previous phases, so we decided to adapt it in the testing stage for code generation. The test cases from Marmoset are great resource that can help us to test our compiler, so we made a JUnit test suit performing parameterized testing for each each Marmoset test case.

All the test cases created by us and from Marmoset have been passed successfully. This shows that our program is correct and robust. 