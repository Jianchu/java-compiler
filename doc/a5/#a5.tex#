\documentclass[a4paper, notitlepage]{report}
\usepackage{graphicx}

\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{listings}
%\usepackage[parfill]{parskip}
\usepackage[a4paper,left=3cm,right=3cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{titlesec, color}
%\usepackage[T1]{fontenc}
%\definecolor{gray75}{gray}{0.75}
%\newcommand{\hsp}{\hspace{20pt}}
%\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\hsp}{0pt}{\Huge\bfseries}
\usepackage[Lenny]{fncychap}


\usepackage{etoolbox}
\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}

\title{CS444/644 Assignment 1 Technical Report}
\author{Ho-Yi Fung, Jianchu Li, Zhiyuan Lin}
\date{\today}

\begin{document}

{\let\newpage\relax\maketitle}

\vspace{30pt}
\begin{abstract}
bleh
\end{abstract}


\tableofcontents

\newpage

%\begingroup
%\let\clearpage\relax
\chapter{Introduction}



\chapter{Design}
\label{design}

\section{Conventions}

\subsection{Calling Convention}
\label{calling}
A consistent subroutine calling convention is used in all the NASM code generated. The scheme implemented by the team requires that:
\begin{enumerate}
\item All arguments for a subroutine are stored on the stack.
\item The arguments are pushed on to stack from left to right (consistent with the order they are evaluated).
\item In the case where the subroutine is the implementation of an instance method, the object address needs to be pushed to the stack \emph{after} all the arguments. In the case of a static method or a native subroutine, the value \emph{0} (null) is pushed to the stack in place of object address to ensure that the arguments have consistent offsets. This value 0 should never be accessed.
\item The \emph{caller} of a subroutine is responsible for saving registers and restoring registers when calling a subroutine.
\item The \emph{callee} allocates its own stack frame for local variables and cleans the frame at the end of the subroutine.
\item The frame pointer of the caller is pushed on the stack by callee at the very beginning of the subroutine and restored before the subroutine exits. 
\item The caller is responsible for cleaning up the arguments (including object address for instance method).
\item The return value of a subroutine is stored in the register \emph{eax}.
\end{enumerate}

We choose to push arguments onto stack from left to right because this makes left-to-right evaluation of arguments straight-forward. However the object address of an instance method must be evaluated before any arguments to produce side effects consistent with the Java semantics. Therefore the object address is first evaluted and pushed on the stack, and then the arguments are evaluated. However, whenever an argument needs to be pushed onto stack, the code generated would pop the object address from stack, push the argument, and then push the object address back on the stack. This way the object is always kept on the top of the stack and has the same offset for all instance methods.

The order of arguments in this scheme is different from that in \textbf{cdecl} or \textbf{thisdecl} (used by C++ for instance methods), however, because there is no variadic function (variable length argument) in Joos 1W, this scheme works correctly and is time efficient.

In general, this scheme applies no matter the subroutine generated is in effect a Java method or a helper subroutine used in the NASM code generated. The only exceptions are the subroutines provided by the library \emph{runtime.s}, where we will store the input for the subroutine in register \emph{eax}. This includes when the native method \emph{PrintStream.nativeWrite()} is called.

\subsection{Stack Frame and Local Variable Storage}

As specified by the calling convention described in the last section, in a subroutine call the callee allocates and cleans the stack frame. Local variables are assigned addresses in reference to the frame pointer (\emph{ebp}, also called base pointer in NASM). For example the first local variable declared in a Java method is stored in the address (ebp - 4), and the second is in (ebp - 8). The real offset starts from 4 because [ebp] is the old frame pointer from the caller stored by callee, following our calling scheme. Figure~\ref{stack_frame} shows the structure of the stack frame implemented.

\begin{figure}
  \caption{Stack Frame}
  \label{stack_frame}
\end{figure}

% possible algo for stack allocation and cleanup.

\subsection{Class Layout}
\label{class_layout}
For the sake of clarity, we decide to generate an assembly file for each Java class given as input. Each assembly file for Java classe normally has the following components:
\begin{enumerate}
\item pointer to corresponding column in class hierarchy table
\item pointer to corresponding column in interface table
\item Virtual method table for the class
\item Class Fields
\item Separate initialization subroutines for instance and class fields
\item Implementation of methods
\end{enumerate}

In the case where a \emph{test()} method is specified in the class, a \emph{\_start} subroutine is also generated in the class assembly file. The \emph{\_start} subroutine initializes the class fields by calling the initialization subroutines for each class. Within each class the class fields are initialized in the order they are declared. After the initialization, the subroutine that implements the \emph{test()} method in assembly is called. Each non-native method is implemented as a subroutine in assembly and follows the calling convention.

The virtual method table is used in order to support method overriding. It also contains pointers to tables for computing interface method offset and class hierarchy. The detail of the virtual method table will be discussed later in Section~\ref{method_invoke}. 

\subsection{Object and Array Layout}
\label{object_layout}
Space for objects and arrays is allocated using the \emph{\_\_malloc} subroutine provided in the \emph{runtime.s} library. Each object contains a pointer to the virtual method table of its runtime class. This is stored as the first word in the object memory. In each object, the virtual table pointer is followed by the instance fields for the object.

Offsets for instance fields are calculated prior to the actual code generation process, and follows the inheritance relationship between classes to support instance field polymorphism. For example, if class \emph{A} inherits the instance field \emph{x} from class \emph{B}, the field \emph{x} has the same offset in both \emph{A} and \emph{B} objects.

Moreover, hidden fields need to be take into consideration when generating field offsets. In Java, both instance and static fields are inherited, but there is no field polymorphism. In other words, fields are hidden but not overriden. For example in Figure~\ref{field_hiding}, the return value of \emph{B.test()} should be 123. In this example the object \emph{a} must contain space for the field \emph{x} from both class \emph{A} and class \emph{B}. In order to support this feature, each class inherits the layout of its superclass and extends it with the fields declared in itself. Different fields with same name but are declared in different classes need to have different offsets. Unique signatures for each field needs to be generated to support this.

\begin{figure}
\centering
\begin{subfigure}{0.4\textwidth}
\begin{lstlisting}[language=Java, frame=single]
  public class A {
    public int x = 123;
    public A() {}
  }
\end{lstlisting}
\caption{Class A}
\label{field_a}
\end{subfigure}
~
\begin{subfigure}{0.4\textwidth}

\begin{lstlisting}[language=Java, frame=single]
  public class B extends A {
    public int x = 2;
    public B() {}
    public static int test() {
      A a = new B();
      return a.x; // should be 123
    }
  }
\end{lstlisting}
\caption{Class B}
\label{field_b}
\end{subfigure}
\caption{Example of Field Hiding}
\label{field_hiding}
\end{figure}

Arrays have a similar layout with Java objects. The first word in an array points to a virtual method table, which then points to the table column for class hierarchy check. The second entry in an array stores the length of the array, and then the array elements are stored in order.

\subsection{Label Signature Scheme}
In the process of code generation we need to generate assembly labels for elements such as class fields, methods as well as virtual tables. A signature scheme was devised in order to generate globally unique labels. See below for some examples.
\begin{itemize}
\item (Static) Field: \emph{typename}\#\emph{fieldname}
\item Method: \emph{typename}\#\emph{methodname}\$\emph{paramter\_type1}?\emph{parameter\_type2}?...\$
\item Constructor: \emph{typename}\#$\langle$init$rangle$>\$\emph{parameter\_type1}?...\$
\item VTable: VTable\#\emph{typename}
\item Primitive Type: I for \emph{int}, C for \emph{char}, B for \emph{boolean}, V for \emph{void}
\item Class or Interface Type: fully qualified name
\item Array Type: @\emph{element\_type}
\end{itemize}
The \emph{typename} above is the type in which the member (field or method for example) is declared, and it is the fully qualified name of the type. And parameter type signatures follow the above scheme for types. For example the method \emph{x(int[] a)} from class \emph{A.B} has signature \emph{A.B\#x\$@I\$}.

This scheme is designed following the signature scheme used in JVM bytecode. However some delimiters are replaced because they cannot be used in names in NASM.

\section{Code Generation}

In this sections we discuss the design issues in actual code generation. Only challenges and points of interest are introduced here. The code generation for certain statements and expressions merely follows templates available from class and the internet. Such parts are not covered for the sake of brevity.

\subsection{Field and Method}
\label{method_invoke}

As was discussed in Section~\ref{class_layout} and Section~\ref{object_layout}, instance fields are stored in its object memory and static fields are stored under globally unique labels. Consequently the access of an instance field utilises the offset that has been computed for the field before code generation, while the access of a class field is achieved by means of its label.

Accessing an instance method requires a slightly different approach because of method polymorphism. To support method overriding, class specific \emph{virtual method table}s (vtable for short) are used. In our design, the virtual table of a class is prepended by two entries. The first entry of contains a pointer to the subtype table, which will be discussed later in Section~\ref{type_check}, and the second entry contains a pointer to interface method table for interface method calls. Following these two entries are the real virtual method table, which contains the instance method labels in order consistent with their precomuted offsets. As was mentioned in Section~\ref{object_layout}, each object contains a pointer to the virtual table of its runtime class. 

Method access has three main scenarios. The first is instance method call with an object whose static type is a class type. The second is when the object is of interface type statically. The third is static method access.

In the first case, similar to instance fields, offsets are computed for instance methods so that they could be accessed from the class' virtual method table. However because of polymorphism, if an instance method $A.x(...)$ overrides some method $B.x(...)$ from the super class, it must have the same offset as the replaced method, and thus take its place in the virtual table. 

In the case where the method is declared in an interface, the method cannot be accessed simply using the virtual method table, because there can be multiple interfaces, and coordinating the virtual table offsets of methods in multiple interfaces is inefficient. The interface method table is therefore used to facilitate method access in this case. The table is created in the form of selector index arrays. In the table there is a column for each class, and the pointer in each class points to their own column. Each method appearing in one or more interfaces is given a global offset, which indicates their positions in the class columns. An entry in the table is a pointer to the method implementation, if the method is implemented by the class, otherwise it is \emph{null} and should never be accessed. Given a interface instance method call, we find the column that belongs to the object's class, and then find the pointer to the method implementation through offset of the interface method.

Lastly, static method invocation is achieved in assembly by calling the globally unique label of the method implementation, and there is no method overloading for static methods inn Java.

Another issue related to method invocation is the order in which the elements are evaluted. This has been discussed in Section~\ref{calling}.

\subsection{Constructor Calls}

Constructors are invoked through their labels, just like static methods. Constructor calls also follows the calling convention for methods. However, space for the object must be allocated first through the \emph{\_\_malloc} subroutine and the returned pointer to object must be placed on top of all arguments for the constructor. Moreover, the subroutine for instance field initialization must be called before the subroutine that implements the constructor. Besides, each constructor implicitely calls the default constructor of its super class before running its own code. 

\subsection{Dynamic Type Checking}
\label{type_check}

Java requires type checking at runtime for the \emph{cast} expression and \emph{instanceof} expression. This is supported by the subtype table. The subtype table is similar to the interface method table as it contains a column (array) for each type. However in this case columns for array types are included too. When checking if an object $a$ is an instance type $T$, we access the subtype table through $a$'s pointer to its class, and then the pointer in its class to the subtype table column. Each type is also associated with an offset in the subtype table. Therefore we could retrieve $T$'s offset in compile-time and access its entry in $a$'s column based on the offset. The entry is \emph{true} if $a$ is an instance of $T$, and \emph{false} otherwise. The checking for the cast expression goes through the same process.

It should be noted that array types do not have their own assembly files, so their type label is generated in a special file and contains only a pointer to their column in the subtype table.


\clearpage
\chapter{Implementation}
\label{implementation}





\chapter{Testing}
\label{testing}
Following the practice during the implementation of the scanner and parser phases, we adopt the unit testing strategy, and utilizes the JUnit 4 testing framework to test our program. The unit testing strategy allows us to ensure that each requirement from the assignments is satisfied. For example, in order to test that all accesses of protected class members are legal, we created test cases with different class hierarchy and access scenario. This way we can make sure the protected access checking works as expected. Both positive and negative test cases, derived from the language specification, were used in this process. For instance, each rule that should be checked by the type checker has its own test cases to verify that the implementation is correct.

A major purpose of the semantic analysis is to ensure that the subject program conforms to the Joos 1W specification semantically. In each step, a large number of checks is performed. Therefore there are a lot of different functionalities/requirements to be tested. To allow for more efficient testing, we combined smaller test cases for different scenarios into three test suites, one for each assignment.

Because the development includes occasional modifications and bug fixes to the previous modules, we decided to test the program incrementally. Once a module is integrated into the compiler or a major change is made, all the previous test suites are run to ensure that no new bugs are introduced to the program, and the changes work as planned.

The test cases from Marmoset were added to our test suites and tested against after each assignment is finished. In each JUnit 4 test suite, the parameterized testing method was used to run the test cases from Marmoset, so that we can make sure the program passes every test case. 

The final product has successfully passed all the test cases from our test suites. This includes both the test cases created by the team, and those from Marmoset. This gives the team confidence that the implementation is robust and our design reasonable.

\chapter{Conclusion}
In this report we discussed the design and implementation of the semantic analysis phase of our compiler. The implementation is complete and successful. All requirements from the assignments are satisfied, and all test cases, both those devised by the team and those obtained from Marmoset, are passed. The analyses are performed in time linear to the size of the ASTs, therefore their running time is acceptable and would work for even very large programs. There are, of course, ways to improve the program. For example, reachability analysis and variable analysis could be combined to save one traversal of the AST. It was a conscious choice to separate the two functions to achieve better modularized code. Besides, this choice does not affect the program's runtime asymptotically.


\bibliographystyle{ieeetr}
\bibliography{a5}

\end{document}
